---
title: "Let's Build an Ansible Role for Basic Linux Hardening"
date: 2025-04-02
draft: false
slug: ansible-role-linux-hardening
tags: ["Ansible", "Linux", "Security", "Automation", "System Hardening", "Ansible Role", "Tutorial"]
categories: ["Automation & Scripting", "Linux & Open Source", "Security & Privacy", "System Management", "System Hardening", "Sysadmin Life"]
description: "Join me as we build an Ansible role to automate basic Linux security hardening. We'll walk through the key tasks and configurations to secure a fresh system."
---

Alright, let's talk security hardening. It's one of the first, if not *the* first, steps we should take on any new Linux system. But let's be real, doing it all manually gets old fast, especially when we're managing more than a couple of servers. That's where Ansible comes in!

In this post, let's work together to create an Ansible role that automates a lot of the basic hardening. We want to make sure those essential security practices get applied consistently and without us having to remember every single step.

This role we'll build will work for both Debian/Ubuntu and Red Hat/Fedora, which is a lifesaver. It's not about being fancy, it's about getting the basics *right*.

Here's a breakdown of what the role will do, and why each step is important, along with the Ansible code we'll use:

## Core Hardening Tasks (The Ansible Way)

Our role will automate a bunch of the core security stuff we should always do:

### System Tuning

* **Kernel Tweaks:**

    * We'll use `sysctl` to manage kernel parameters. This is where we can do things like harden our network stack.
    * We'll also modify kernel parameters via GRUB. Things like disabling `vsyscall` (it's an older way of doing system calls that can be exploited), turning on page poisoning (which helps catch memory errors), and enabling page table isolation (to mitigate those Meltdown/Spectre vulnerabilities).
    * And yeah, we'll often want to disable IPv6 if we're not using it. Less stuff running generally means less to worry about.

    ```yaml
    - name: Kernel Tweaks
      become: true
      block:
        - name: Set sysctl parameters
          ansible.builtin.sysctl:
            name: "{{ item.key }}"
            value: "{{ item.value }}"
            state: present
          loop:
            - { key: net.ipv4.tcp_syncookies, value: '1' }
            - { key: net.ipv4.conf.all.accept_redirects, value: '0' }
            # ... other sysctl settings ...

        - name: Disable vsyscall (Debian/Ubuntu)
          ansible.builtin.lineinfile:
            path: /etc/default/grub
            regexp: '^GRUB_CMDLINE_LINUX='
            line: 'GRUB_CMDLINE_LINUX="vsyscall=none"'
          when: ansible_os_family == "Debian"
          notify: Update GRUB

        - name: Disable vsyscall (Red Hat/Fedora)
          ansible.builtin.command:
            cmd: grubby --update-kernel=ALL --args="vsyscall=none"
          when: ansible_os_family == "RedHat"
          notify: Update GRUB

        - name: Disable IPv6
          ansible.builtin.sysctl:
            name: net.ipv6.conf.all.disable_ipv6
            value: '1'
            state: present
          when: disable_ipv6
    ```

    * **Explanation:**
        * `sysctl` lets us change kernel parameters at runtime. We use `loop` to set multiple parameters.
        * `lineinfile` modifies the GRUB config on Debian/Ubuntu.
        * `command` runs `grubby` on Red Hat/Fedora (since it doesn't use `/etc/default/grub` in the same way).
        * `when` conditions ensure tasks only run on the relevant OS family or when a variable (`disable_ipv6`) is true.
        * `notify` triggers a handler to update GRUB (not shown here, but essential).

* **Systemd Setup:**

    * We need to make sure `system.conf`, `user.conf`, and `journald.conf` are set up properly. Systemd is core, so we want it secure.

    ```yaml
    - name: Systemd Configuration
      become: true
      block:
        - name: Configure system.conf
          ansible.builtin.template:
            src: system.conf.j2
            dest: /etc/systemd/system.conf
            owner: root
            group: root
            mode: 0644
          notify: Restart systemd

        - name: Configure user.conf
          ansible.builtin.template:
            src: user.conf.j2
            dest: /etc/systemd/user.conf
            owner: root
            group: root
            mode: 0644

        - name: Configure journald.conf
          ansible.builtin.template:
            src: journald.conf.j2
            dest: /etc/systemd/journald.conf
            owner: root
            group: root
            mode: 0644
          notify: Restart systemd-journald
    ```

    * **Explanation:**
        * `template` deploys configuration files from Jinja2 templates. This lets us use variables.
        * `notify` triggers handlers to restart systemd services (not shown).

### Package Management

* **USBGuard:**

    * This is *awesome*. It lets us control which USB devices can actually *do* anything on our system. Super important for physical security. Our role will set this up.

    ```yaml
    - name: USBGuard
      become: true
      block:
        - name: Install USBGuard
          ansible.builtin.package:
            name: usbguard
            state: present

        - name: Configure USBGuard (example rule)
          ansible.builtin.lineinfile:
            path: /etc/usbguard/rules.conf
            line: 'allow id * serial "*" name "Trusted USB Drive" hash "*" parent-id "" via-port "" with-interface { 03:00:00 }'
            create: true
    ```

    * **Explanation:**
        * `package` installs the `usbguard` package.
        * `lineinfile` adds a rule to the USBGuard configuration.  **Important:** This is just an *example* rule!  USBGuard rules are complex and depend on your specific needs. You'll need to learn more about USBGuard's syntax.

* **Package Management:**

    * This is basic, but the role will make sure we've got the right packages installed and everything's up-to-date. `apt` on Debian/Ubuntu, `dnf` on Red Hat/Fedora.

    ```yaml
    - name: Install Essential Packages
      become: true
      block:
        - name: Debian/Ubuntu packages
          ansible.builtin.apt:
            name:
              - fail2ban
              - ufw # (Uncomplicated Firewall)
            state: present
            update_cache: true
          when: ansible_os_family == "Debian"

        - name: Red Hat/Fedora packages
          ansible.builtin.dnf:
            name:
              - fail2ban
              - firewalld
            state: present
            update_cache: true
          when: ansible_os_family == "RedHat"
    ```

    * **Explanation:**
        * `apt` and `dnf` install packages. `update_cache: true` updates the package list first.
        * We install `ufw` on Debian/Ubuntu and `firewalld` on Red Hat/Fedora, as those are the standard firewalls.

* **Auto-Updates:**

    * We *always* need to set up unattended upgrades. Security updates *must* be installed automatically.

    ```yaml
    - name: Auto-Updates
      become: true
      block:
        - name: Debian/Ubuntu unattended-upgrades
          ansible.builtin.apt:
            name: unattended-upgrades
            state: present
          when: ansible_os_family == "Debian"

        - name: Configure unattended-upgrades
          ansible.builtin.template:
            src: unattended-upgrades.j2
            dest: /etc/apt/apt.conf.d/50unattended-upgrades
            owner: root
            group: root
            mode: 0644
          when: ansible_os_family == "Debian"

        - name: Enable dnf-automatic (Red Hat/Fedora)
          ansible.builtin.dnf:
            name: dnf-automatic
            state: present
          when: ansible_os_family == "RedHat"

        - name: Configure dnf-automatic
          ansible.builtin.template:
            src: dnf-automatic.j2
            dest: /etc/etc/dnf/automatic.conf
            owner: root
            group: root
            mode: 0644
          when: ansible_os_family == "RedHat"
    ```

    * **Explanation:**
        * We install the necessary packages (`unattended-upgrades` or `dnf-automatic`) and then use `template` to configure them.

### Security Essentials

* **Host Access:**

    * `hosts.allow` and `hosts.deny` are older tools, but they're still a good extra layer of network control. The role will configure them.

    ```yaml
    - name: Host Access Control
      become: true
      block:
        - name: Configure hosts.allow
          ansible.builtin.template:
            src: hosts.allow.j2
            dest: /etc/hosts.allow
            owner: root
            group: root
            mode: 0644

        - name: Configure hosts.deny
          ansible.builtin.template:
            src: hosts.deny.j2
            dest: /etc/hosts.deny
            owner: root
            group: root
            mode: 0644
    ```

    * **Explanation:**
        * `template` is used to deploy the `hosts.allow` and `hosts.deny` files.  These files control which hosts are allowed or denied access to services.

* **Login Limits:**

    * Files like `login.defs` and `limits.conf` are where we set things like password complexity, login retries, and resource limits. Our role will make sure these are sane.

    ```yaml
    - name: Login Limits
      become: true
      block:
        - name: Configure login.defs
          ansible.builtin.template:
            src: login.defs.j2
            dest: /etc/login.defs
            owner: root
            group: root
            mode: 0644

        - name: Configure limits.conf
          ansible.builtin.template:
            src: limits.conf.j2
            dest: /etc/security/limits.conf
            owner: root
            group: root
            mode: 0644
    ```

    * **Explanation:**
        * Again, `template` is used to configure these files. `login.defs` sets system-wide password and login policies, while `limits.conf` sets resource limits for users.

* **Core Dumps:**

    * We want to handle core dumps securely. The role will take care of that, and also disable `kdump` (it can be a security risk if not configured carefully).

    ```yaml
    - name: Core Dumps
      become: true
      block:
        - name: Configure coredump.conf
          ansible.builtin.template:
            src: coredump.conf.j2
            dest: /etc/systemd/coredump.conf
            owner: root
            group: root
            mode: 0644

        - name: Disable kdump
          ansible.builtin.service:
            name: kdump
            state: absent # Or 'stopped' and 'disabled'
            enabled: false
    ```

    * **Explanation:**
        * `template` configures `coredump.conf` to control how core dumps are handled.
        * `service` disables the `kdump` service.

* **PAM:**

    * PAM is what handles authentication. The role will set it up with strong settings.

    ```yaml
    - name: PAM Configuration
      become: true
      block:
        - name: Configure PAM common-auth
          ansible.builtin.template:
            src: common-auth.j2
            dest: /etc/pam.d/common-auth
            owner: root
            group: root
            mode: 0644

        - name: Configure PAM common-password
          ansible.builtin.template:
            src: common-password.j2
            dest: /etc/pam.d/common-password
            owner: root
            group: root
            mode: 0644

        # ... other PAM configurations ...
    ```

    * **Explanation:**
        * `template` configures key PAM files (`common-auth`, `common-password`, etc.) to enforce strong authentication.

* **SSH:**

    * SSH *has* to be secure. The role will enforce best practices.

    ```yaml
    - name: SSH Hardening
      become: true
      block:
        - name: Configure sshd_config
          ansible.builtin.template:
            src: sshd_config.j2
            dest: /etc/ssh/sshd_config
            owner: root
            group: root
            mode: 0644
          notify: Restart sshd

        # ... other SSH hardening tasks (keys, firewall rules, etc.) ...
    ```

    * **Explanation:**
        * `template` configures the `sshd_config` file, which is the main SSH server configuration.

* **Filesystem Mounts:**

    * Mounting filesystems with options like `nosuid`, `nodev`, and `noexec` is a simple way to prevent a lot of attacks. The role will do this for us.

    ```yaml
    - name: Filesystem Mounts
      become: true
      block:
        - name: Mount /tmp with noexec
          ansible.posix.mount:
            path: /tmp
            opts: rw,noexec,nosuid,nodev
            state: mounted
            fstype: tmpfs

        - name: Mount /var with nodev,nosuid
          ansible.posix.mount:
            path: /var
            opts: rw,nodev,nosuid
            state: mounted
            fstype: ext4 # Or whatever your /var filesystem is
    ```

    * **Explanation:**
        * `ansible.posix.mount` is used to ensure filesystems are mounted with the specified options.

### Logging and Time

* **Log Rotation:**

    * `logrotate` is essential. We don't want our logs filling up our disks.

    ```yaml
    - name: Log Rotation
      become: true
      block:
        - name: Configure logrotate
          ansible.builtin.template:
            src: logrotate.conf.j2
            dest: /etc/logrotate.conf
            owner: root
            group: root
            mode: 0644

        # ... other logrotate configurations ...
    ```

    * **Explanation:**
        * `template` configures the main `logrotate.conf` file.

* **System Logging:**

    * `rsyslog` needs to be set up securely.

    ```yaml
    - name: System Logging
      become: true
      block:
        - name: Configure rsyslog
          ansible.builtin.template:
            src: rsyslog.conf.j2
            dest: /etc/rsyslog.conf
            owner: root
            group: root
            mode: 0644

        # ... other rsyslog configurations ...
    ```

    * **Explanation:**
        * `template` configures `rsyslog.conf`.

* **Time Sync:**

    * Accurate time is crucial for logs, so we'll use `systemd-timesyncd`.

    ```yaml
    - name: Time Synchronization
      become: true
      block:
        - name: Ensure systemd-timesyncd is installed
          ansible.builtin.package:
            name: systemd-timesyncd
            state: present

        - name: Enable and start systemd-timesyncd
          ansible.builtin.service:
            name: systemd-timesyncd
            enabled: true
            state: started

        - name: Configure systemd-timesyncd
          ansible.builtin.template:
            src: timesyncd.conf.j2
            dest: /etc/systemd/timesyncd.conf
            owner: root
            group: root
            mode: